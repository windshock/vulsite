package com.vulsite.vulnerability;

import com.vulsite.entity.User;
import com.vulsite.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mock.web.MockHttpSession;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * A담당 - 취약점 #9: IDOR (타사용자 정보 수정) 보안 기대 테스트
 *
 * 테스트 시나리오 (보안 기대):
 * 1. 자신의 정보 수정 (정상)
 * 2. 다른 사용자 ID로 정보 수정 시도 (차단)
 * 3. 관리자 정보 수정 시도 (차단)
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
@Transactional
@Tag("secure")
class IdorUserUpdateTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    private User attacker;
    private User victim;
    private User admin;

    @BeforeEach
    void setUp() {
        // 공격자 (로그인할 사용자)
        attacker = new User("attacker", "attackerpass", "attacker@test.com", "공격자");
        attacker = userRepository.save(attacker);

        // 피해자 (정보를 수정당할 사용자)
        victim = new User("victim", "victimpass", "victim@test.com", "피해자");
        victim = userRepository.save(victim);

        // 관리자
        admin = new User("adminuser", "adminpass", "admin@test.com", "관리자");
        admin.setAdmin(true);
        admin = userRepository.save(admin);
    }

    private MockHttpSession createLoginSession(User user) {
        MockHttpSession session = new MockHttpSession();
        session.setAttribute("user", user);
        session.setAttribute("userId", user.getId());
        return session;
    }

    @Test
    @DisplayName("[정상] 자신의 프로필 조회")
    void viewOwnProfile_shouldSucceed() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        mockMvc.perform(get("/user/profile/" + attacker.getId())
                        .session(session))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("profileUser"));
    }

    @Test
    @DisplayName("[정상] 자신의 정보 수정")
    void updateOwnInfo_shouldSucceed() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        mockMvc.perform(post("/user/update")
                        .session(session)
                        .param("userId", attacker.getId().toString())
                        .param("email", "newemail@test.com")
                        .param("name", "새이름"))
                .andExpect(status().is3xxRedirection());

        // DB에서 변경 확인
        User updated = userRepository.findById(attacker.getId()).orElseThrow();
        assertThat(updated.getEmail()).isEqualTo("newemail@test.com");
        assertThat(updated.getName()).isEqualTo("새이름");

        System.out.println("[정상 테스트] 자신의 정보 수정 성공");
    }

    @Test
    @DisplayName("[보안 기대] IDOR - 다른 사용자 정보 수정은 차단되어야 함")
    void updateOtherUserInfo_shouldBeBlocked() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        String originalEmail = victim.getEmail();
        String originalName = victim.getName();

        mockMvc.perform(post("/user/update")
                        .session(session)
                        .param("userId", victim.getId().toString())  // 피해자 ID
                        .param("email", "hacked@evil.com")
                        .param("name", "해킹됨"))
                .andExpect(status().is4xxClientError());

        User updatedVictim = userRepository.findById(victim.getId()).orElseThrow();
        assertThat(updatedVictim.getEmail()).isEqualTo(originalEmail);
        assertThat(updatedVictim.getName()).isEqualTo(originalName);
    }

    @Test
    @DisplayName("[보안 기대] IDOR - 관리자 정보 수정은 차단되어야 함")
    void updateAdminInfo_shouldBeBlocked() throws Exception {
        MockHttpSession session = createLoginSession(attacker);
        String originalEmail = admin.getEmail();
        String originalName = admin.getName();

        mockMvc.perform(post("/user/update")
                        .session(session)
                        .param("userId", admin.getId().toString())  // 관리자 ID
                        .param("email", "admin_hacked@evil.com")
                        .param("name", "탈취된관리자"))
                .andExpect(status().is4xxClientError());

        User updatedAdmin = userRepository.findById(admin.getId()).orElseThrow();
        assertThat(updatedAdmin.getEmail()).isEqualTo(originalEmail);
        assertThat(updatedAdmin.getName()).isEqualTo(originalName);
    }

    @Test
    @DisplayName("[보안 기대] 비로그인 상태에서는 정보 수정 불가")
    void updateWithoutLogin_shouldBeBlocked() throws Exception {
        String originalEmail = victim.getEmail();
        String originalName = victim.getName();

        mockMvc.perform(post("/user/update")
                        .param("userId", victim.getId().toString())
                        .param("email", "nologin@evil.com")
                        .param("name", "비로그인공격"))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/user/login"));

        User result = userRepository.findById(victim.getId()).orElseThrow();
        assertThat(result.getEmail()).isEqualTo(originalEmail);
        assertThat(result.getName()).isEqualTo(originalName);
    }

    @Test
    @DisplayName("[보안 기대] userId 파라미터 조작은 차단되어야 함")
    void idorBruteforce_shouldBeBlocked() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        for (long id = 1; id <= 10; id++) {
            mockMvc.perform(post("/user/update")
                            .session(session)
                            .param("userId", String.valueOf(id))
                            .param("email", "bruteforce" + id + "@evil.com")
                            .param("name", "브루트포스" + id))
                    .andExpect(status().is4xxClientError());
        }
    }
}
