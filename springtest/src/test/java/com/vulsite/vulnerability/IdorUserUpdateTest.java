package com.vulsite.vulnerability;

import com.vulsite.entity.User;
import com.vulsite.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mock.web.MockHttpSession;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * A담당 - 취약점 #9: IDOR (타사용자 정보 수정) 테스트
 *
 * 테스트 시나리오:
 * 1. 자신의 정보 수정 (정상)
 * 2. 다른 사용자 ID로 정보 수정 시도 (취약점)
 * 3. 관리자 정보 수정 시도 (취약점)
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
@Transactional
class IdorUserUpdateTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    private User attacker;
    private User victim;
    private User admin;

    @BeforeEach
    void setUp() {
        // 공격자 (로그인할 사용자)
        attacker = new User("attacker", "attackerpass", "attacker@test.com", "공격자");
        attacker = userRepository.save(attacker);

        // 피해자 (정보를 수정당할 사용자)
        victim = new User("victim", "victimpass", "victim@test.com", "피해자");
        victim = userRepository.save(victim);

        // 관리자
        admin = new User("adminuser", "adminpass", "admin@test.com", "관리자");
        admin.setAdmin(true);
        admin = userRepository.save(admin);
    }

    private MockHttpSession createLoginSession(User user) {
        MockHttpSession session = new MockHttpSession();
        session.setAttribute("user", user);
        session.setAttribute("userId", user.getId());
        return session;
    }

    @Test
    @DisplayName("[정상] 자신의 프로필 조회")
    void viewOwnProfile_shouldSucceed() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        mockMvc.perform(get("/user/profile/" + attacker.getId())
                        .session(session))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("profileUser"));
    }

    @Test
    @DisplayName("[정상] 자신의 정보 수정")
    void updateOwnInfo_shouldSucceed() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        mockMvc.perform(post("/user/update")
                        .session(session)
                        .param("userId", attacker.getId().toString())
                        .param("email", "newemail@test.com")
                        .param("name", "새이름"))
                .andExpect(status().is3xxRedirection());

        // DB에서 변경 확인
        User updated = userRepository.findById(attacker.getId()).orElseThrow();
        assertThat(updated.getEmail()).isEqualTo("newemail@test.com");
        assertThat(updated.getName()).isEqualTo("새이름");

        System.out.println("[정상 테스트] 자신의 정보 수정 성공");
    }

    @Test
    @DisplayName("[취약점 #9] IDOR - 다른 사용자 정보 수정")
    void updateOtherUserInfo_shouldSucceed_vulnerability() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        String originalEmail = victim.getEmail();
        String originalName = victim.getName();

        // 공격자가 피해자의 userId로 정보 수정 요청
        mockMvc.perform(post("/user/update")
                        .session(session)
                        .param("userId", victim.getId().toString())  // 피해자 ID
                        .param("email", "hacked@evil.com")
                        .param("name", "해킹됨"))
                .andExpect(status().is3xxRedirection());

        // 피해자 정보가 변경되었는지 확인
        User hackedVictim = userRepository.findById(victim.getId()).orElseThrow();

        assertThat(hackedVictim.getEmail()).isEqualTo("hacked@evil.com");
        assertThat(hackedVictim.getName()).isEqualTo("해킹됨");

        System.out.println("[취약점 확인] IDOR로 타사용자 정보 수정 성공");
        System.out.println("  원래 이메일: " + originalEmail + " -> 변경된 이메일: " + hackedVictim.getEmail());
        System.out.println("  원래 이름: " + originalName + " -> 변경된 이름: " + hackedVictim.getName());
    }

    @Test
    @DisplayName("[취약점 #9] IDOR - 관리자 정보 수정")
    void updateAdminInfo_shouldSucceed_vulnerability() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        // 일반 사용자가 관리자 정보 수정 시도
        mockMvc.perform(post("/user/update")
                        .session(session)
                        .param("userId", admin.getId().toString())  // 관리자 ID
                        .param("email", "admin_hacked@evil.com")
                        .param("name", "탈취된관리자"))
                .andExpect(status().is3xxRedirection());

        // 관리자 정보가 변경되었는지 확인
        User hackedAdmin = userRepository.findById(admin.getId()).orElseThrow();

        assertThat(hackedAdmin.getEmail()).isEqualTo("admin_hacked@evil.com");
        assertThat(hackedAdmin.getName()).isEqualTo("탈취된관리자");

        System.out.println("[취약점 확인] IDOR로 관리자 정보 수정 성공");
        System.out.println("  관리자 이메일: " + hackedAdmin.getEmail());
    }

    @Test
    @DisplayName("[취약점 #9] IDOR - 비로그인 상태에서 정보 수정 시도")
    void updateWithoutLogin_shouldFail() throws Exception {
        // 세션 없이 요청 (비로그인)
        mockMvc.perform(post("/user/update")
                        .param("userId", victim.getId().toString())
                        .param("email", "nologin@evil.com")
                        .param("name", "비로그인공격"))
                .andExpect(status().is3xxRedirection());  // 리다이렉트되지만 수정은 됨

        User result = userRepository.findById(victim.getId()).orElseThrow();

        // 로그인 체크가 없다면 수정됨 (취약)
        if ("nologin@evil.com".equals(result.getEmail())) {
            System.out.println("[취약점 확인] 비로그인 상태에서도 정보 수정 가능");
        } else {
            System.out.println("[정보] 비로그인 상태에서는 수정 불가");
        }
    }

    @Test
    @DisplayName("[취약점 #9] IDOR - userId 파라미터 조작 (연속 ID)")
    void idorBruteforce_shouldExposeVulnerability() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        // ID를 1부터 순회하며 수정 시도 (실제 공격 시나리오)
        for (long id = 1; id <= 10; id++) {
            try {
                mockMvc.perform(post("/user/update")
                                .session(session)
                                .param("userId", String.valueOf(id))
                                .param("email", "bruteforce" + id + "@evil.com")
                                .param("name", "브루트포스" + id))
                        .andExpect(status().is3xxRedirection());

                System.out.println("[IDOR 성공] userId=" + id + " 수정 완료");
            } catch (Exception e) {
                System.out.println("[IDOR 실패] userId=" + id + " 존재하지 않음");
            }
        }
    }
}
