package com.vulsite.vulnerability;

import com.vulsite.entity.Board;
import com.vulsite.entity.User;
import com.vulsite.repository.BoardRepository;
import com.vulsite.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mock.web.MockHttpSession;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * A담당 - 취약점 #10: IDOR (타사용자 글 삭제) 보안 기대 테스트
 *
 * 테스트 시나리오 (보안 기대):
 * 1. 자신의 글 삭제 (정상)
 * 2. 다른 사용자의 글 삭제 시도 (차단)
 * 3. 관리자 글 삭제 시도 (차단)
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
@Transactional
@Tag("secure")
class IdorBoardDeleteTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BoardRepository boardRepository;

    private User attacker;
    private User victim;
    private User admin;

    private Board attackerPost;
    private Board victimPost;
    private Board adminPost;

    @BeforeEach
    void setUp() {
        // 사용자 생성
        attacker = new User("attacker", "attackerpass", "attacker@test.com", "공격자");
        attacker = userRepository.save(attacker);

        victim = new User("victim", "victimpass", "victim@test.com", "피해자");
        victim = userRepository.save(victim);

        admin = new User("adminuser", "adminpass", "admin@test.com", "관리자");
        admin.setAdmin(true);
        admin = userRepository.save(admin);

        // 게시글 생성
        attackerPost = new Board("공격자의 글", "공격자가 작성한 내용", attacker);
        attackerPost = boardRepository.save(attackerPost);

        victimPost = new Board("피해자의 중요한 글", "피해자가 작성한 중요한 내용", victim);
        victimPost = boardRepository.save(victimPost);

        adminPost = new Board("관리자 공지사항", "중요 공지사항입니다.", admin);
        adminPost = boardRepository.save(adminPost);
    }

    private MockHttpSession createLoginSession(User user) {
        MockHttpSession session = new MockHttpSession();
        session.setAttribute("user", user);
        session.setAttribute("userId", user.getId());
        return session;
    }

    @Test
    @DisplayName("[정상] 자신이 작성한 글 삭제")
    void deleteOwnPost_shouldSucceed() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        mockMvc.perform(post("/board/delete/" + attackerPost.getId())
                        .session(session))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/board"));

        // DB에서 삭제 확인
        Optional<Board> deleted = boardRepository.findById(attackerPost.getId());
        assertThat(deleted).isEmpty();

        System.out.println("[정상 테스트] 자신의 글 삭제 성공");
    }

    @Test
    @DisplayName("[보안 기대] IDOR - 다른 사용자의 글 삭제는 차단되어야 함")
    void deleteOtherUserPost_shouldBeBlocked() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        Long victimPostId = victimPost.getId();

        mockMvc.perform(post("/board/delete/" + victimPostId)
                        .session(session))
                .andExpect(status().is4xxClientError());

        Optional<Board> remaining = boardRepository.findById(victimPostId);
        assertThat(remaining).isPresent();
    }

    @Test
    @DisplayName("[보안 기대] IDOR - 관리자 공지사항 삭제는 차단되어야 함")
    void deleteAdminPost_shouldBeBlocked() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        Long adminPostId = adminPost.getId();

        mockMvc.perform(post("/board/delete/" + adminPostId)
                        .session(session))
                .andExpect(status().is4xxClientError());

        Optional<Board> remaining = boardRepository.findById(adminPostId);
        assertThat(remaining).isPresent();
    }

    @Test
    @DisplayName("[보안 기대] 비로그인 상태에서는 글 삭제 불가")
    void deleteWithoutLogin_shouldBeBlocked() throws Exception {
        Long victimPostId = victimPost.getId();

        mockMvc.perform(post("/board/delete/" + victimPostId))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/user/login"));

        Optional<Board> result = boardRepository.findById(victimPostId);
        assertThat(result).isPresent();
    }

    @Test
    @DisplayName("[보안 기대] 게시글 ID 브루트포스 삭제는 차단되어야 함")
    void idorBruteforceDelete_shouldBeBlocked() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        for (int i = 0; i < 5; i++) {
            Board post = new Board("테스트 글 " + i, "내용 " + i, victim);
            boardRepository.save(post);
        }

        long totalBefore = boardRepository.count();

        for (long id = 1; id <= 20; id++) {
            mockMvc.perform(post("/board/delete/" + id)
                            .session(session))
                    .andExpect(status().is4xxClientError());
        }

        long totalAfter = boardRepository.count();
        assertThat(totalAfter).isEqualTo(totalBefore);
    }

    @Test
    @DisplayName("[보안 기대] 작성자 외 삭제는 불가해야 함")
    void verifyAuthorizationCheck() throws Exception {
        MockHttpSession session = createLoginSession(attacker);

        long victimPostCount = boardRepository.findByAuthorId(victim.getId()).size();

        for (Board post : boardRepository.findByAuthorId(victim.getId())) {
            mockMvc.perform(post("/board/delete/" + post.getId())
                            .session(session))
                    .andExpect(status().is4xxClientError());
        }

        long remainingPosts = boardRepository.findByAuthorId(victim.getId()).size();
        assertThat(remainingPosts).isEqualTo(victimPostCount);
    }
}
