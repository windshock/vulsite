package com.vulsite.vulnerability;

import com.vulsite.entity.User;
import com.vulsite.repository.UserRepository;
import com.vulsite.service.UserService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * A담당 - 취약점 #1: SQL Injection 보안 테스트
 *
 * 테스트 시나리오 (보안 기대):
 * 1. 정상 로그인은 성공해야 함
 * 2. SQL Injection 공격은 차단되어야 함 (로그인 실패)
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
@Transactional
@Tag("secure")
class SqlInjectionTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private UserService userService;

    private User testAdmin;
    private User testUser;

    @BeforeEach
    void setUp() {
        if (userRepository.findByUsername("testadmin").isEmpty()) {
            testAdmin = new User("testadmin", "testpass123", "testadmin@test.com", "테스트관리자");
            testAdmin.setAdmin(true);
            userRepository.save(testAdmin);
        }

        if (userRepository.findByUsername("testuser").isEmpty()) {
            testUser = new User("testuser", "userpass123", "testuser@test.com", "테스트사용자");
            userRepository.save(testUser);
        }
    }

    @Test
    @DisplayName("[정상] 올바른 계정으로 로그인 성공")
    void login_withValidCredentials_shouldSucceed() throws Exception {
        mockMvc.perform(post("/user/login")
                        .param("username", "testadmin")
                        .param("password", "testpass123"))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));
    }

    @Test
    @DisplayName("[정상] 잘못된 비밀번호로 로그인 실패")
    void login_withInvalidPassword_shouldFail() throws Exception {
        mockMvc.perform(post("/user/login")
                        .param("username", "testadmin")
                        .param("password", "wrongpassword"))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("error"));
    }

    @Test
    @DisplayName("[보안 기대] SQL Injection ' OR '1'='1' -- 공격은 차단되어야 함")
    void sqlInjection_withOrPayload_shouldBeBlocked() throws Exception {
        // 보안 적용 시: SQL Injection 페이로드가 단순 문자열로 처리되어 로그인 실패
        mockMvc.perform(post("/user/login")
                        .param("username", "' OR '1'='1' --")
                        .param("password", "anything"))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("error"));
    }

    @Test
    @DisplayName("[보안 기대] SQL Injection admin'-- 공격은 차단되어야 함")
    void sqlInjection_withCommentPayload_shouldBeBlocked() throws Exception {
        // 보안 적용 시: 주석 처리 시도가 차단되어 로그인 실패
        mockMvc.perform(post("/user/login")
                        .param("username", "testadmin'--")
                        .param("password", "anything"))
                .andExpect(status().isOk())
                .andExpect(model().attributeExists("error"));
    }

    @Test
    @DisplayName("[보안 기대] Service 레이어 - SQL Injection은 null 반환해야 함")
    void sqlInjection_atServiceLayer_shouldReturnNull() {
        // 정상 로그인은 성공
        User normalLogin = userService.loginVulnerable("testadmin", "testpass123");
        assertThat(normalLogin).isNotNull();
        assertThat(normalLogin.getUsername()).isEqualTo("testadmin");

        // 보안 적용 시: SQL Injection은 실패 (null 반환)
        User hackedLogin = userService.loginVulnerable("' OR '1'='1' --", "doesntmatter");
        assertThat(hackedLogin).isNull();
    }

    @Test
    @DisplayName("[보안 기대] 다양한 SQL Injection 페이로드는 모두 차단되어야 함")
    void sqlInjection_withVariousPayloads_shouldAllBeBlocked() throws Exception {
        String[] payloads = {
            "' OR ''='",
            "' OR 1=1 --",
            "admin' #",
            "' OR 'x'='x"
        };

        for (String payload : payloads) {
            mockMvc.perform(post("/user/login")
                            .param("username", payload)
                            .param("password", "test"))
                    .andExpect(status().isOk())
                    .andExpect(model().attributeExists("error"));
        }
    }
}
